// Adapted from http://math-crunching.blogspot.com/2015/12/sar-logic-verilog-hdl-code.html
// implemented as a state machine

`timescale 100ns/1ns

module sar_logic(clk,go,valid,result, sample,value,cmp);
   input    clk;              // clock input
   input    st_conv;          // st_conv has to move from hi to lo to start a conversion
   output   done;             // done=1 when conversion finishes
   output   [11:0]  result;   // 12 bit result output
   output   sample;           // to S&H switch. Active high
   output   [11:0]  value;    // to DAC
   input    comp;             // comparator output
   reg  [1:0]  state;         // current state in state machine
   reg  [11:0]  mask;         // bit to test in binary search
   reg  [11:0]  result;       // hold partially converted result
   
   // state assignment
   parameter sWait=0, sSample=1, sConv=2, sDone=3;
   
   // synchronous design
   always @(posedge clk) begin
   case (state)  // choose next state in state machine
      sWait : 
         begin
         if (!st_conv)
            // If st_conv is low, continue waiting
            state <= sWait;
         else
            // If st_conv is high, start the sample process
            state <= sSample;
            result <= 0;
         end
      
      sSample :
         begin 
         // start conversion when st_conv falls
         if (!st_conv)
            state <= sConv;
         else
         // continue sampling process conversion when st_conv is high 
            state <= sSample;
         mask  <=  12'b1000_0000_0000;  // reset mask to MSB only
         result  <=  12'b0000_0000_0000;   // clear result
         end
      
      sConv :
         begin
         // set bit if comparator indicates input larger than
         // value currently under consideration, else leave bit clear
         if (cmp)  result  <= result | mask;

         // shift mask to try next bit next time
         mask <= mask>>1;

         // finished once LSB has been done
         if (mask[0])  state <= sDone;
         end
      sDone : state <= sWait;
   endcase
   end

   assign sample = state==sSample;  // drive sample and hold
   assign value = result | mask;   // (result so far) OR (bit to try)
   assign valid = state==sDone;   // indicate when finished

endmodule
